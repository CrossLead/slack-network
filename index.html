<!DOCTYPE html>
<head>
  <style>
    body {
      background: #ccc;
    }
    svg {
      background: #fff;
      border: 1px solid #000;
    }
    image {
      border-radius: 100%;
    }
    h1 {
      width: 100%;
      top: 20px;
      text-align: center;
      position: fixed;
    }

    #reset {
      top: 20px;
      left: 20px;
      position: fixed;
    }
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css">
</head>
<h1>
  Slackers
</h1>
<button id="reset">
  Reset
</button>
<svg width="100%" height="98vh">
  <defs>
    <clipPath id="clipCircle">
      <circle r="16" cx="0" cy="0"/>
    </clipPath>
  </defs>
</svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://packd.now.sh/slack@8.3.0"></script>
<script
  src="https://code.jquery.com/jquery-2.2.4.min.js"
  integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
<script>

/**
 * slack token should be querystring in url
 */
const token = getParameterByName('token');

main()
  .catch(err => {
    console.log(err.stack);
  })

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

async function main() {
  const channelHash = await getChannelMap();
  const userHash = await getUserHash();
  let nodeMap = new Map();
  let edgeMap = new Map();

  var svg = d3.select("svg"),
      color = d3.scaleOrdinal(d3.schemeCategory10);

  const { width, height } = svg.node().getBoundingClientRect();

  // var min_zoom = 0.1;
  // var max_zoom = 7;
  // var zoom = d3.behavior.zoom().scaleExtent([min_zoom,max_zoom]);

  svg
    .attr("viewBox", "0 0 " + width + " " + height)
    .attr("preserveAspectRatio", "xMidYMid meet");

  // build the arrow.
  svg.append("svg:defs").selectAll("marker")
      .data(["end"])      // Different link/path types can be defined here
    .enter().append("svg:marker")    // This section adds in the arrows
      .attr("id", String)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 39)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5");


  var nodes = [],
      links = [],
      maxWeight = 1;

  var simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink().id(function(d) { return d.index }).distance(150))
      .force("collide",d3.forceCollide( function(d){return d.r + 8 }).iterations(16) )
      .force("charge", d3.forceManyBody().strength(-100))
      .force("y", d3.forceY())
      .force("x", d3.forceX())
      .on("tick", ticked);

  var g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"),
      link = g.append("g").attr("stroke", "#000").attr("marker-end", "url(#end)").selectAll(".link"),
      node = g.append("g").attr("stroke", "#fff").attr("stroke-width", 1.5).selectAll(".node");

  const bot = slack.rtm.client();

  bot.listen({ token });

  const start = Date.now();

  bot.message(message => {
    if ((new Date(message.ts * 1000)) < start) return;
    if (message.user) toastr.info(`New message from @${userHash[message.user].name}`);

    const otherUsers = channelHash[message.channel];

    if (otherUsers) {
      const newEdges = [];
      const newNodes = [];

      otherUsers.forEach(recievingUserId => {
        if (recievingUserId === message.user) return;

        const A = nodeMap.get(message.user) || { id: message.user };
        const B = nodeMap.get(recievingUserId) || { id: recievingUserId };


        if (!nodeMap.has(B.id)) {
          newNodes.push(B);
          nodeMap.set(B.id, B);
        }

        if (!nodeMap.has(A.id)) {
          newNodes.push(A);
          nodeMap.set(A.id, A);
        }

        const messageHash = [message.user, recievingUserId].sort().join('-');

        let edge = edgeMap.get(messageHash);
        if (!edge) {
          edge = { source: A, target: B, weight: 1 };
          edgeMap.set(messageHash, edge);
          newEdges.push(edge);
        } else {
          edge.weight++;
          maxWeight = Math.max(maxWeight, edge.weight);
        }
      });

      nodes.push(...newNodes);
      links.push(...newEdges);
    }

    restart();
  });

  d3.select('#reset')
    .on('click', clear);

  function clear() {
    while (nodes.pop()) {}
    while (links.pop()) {}
    nodeMap = new Map();
    edgeMap = new Map();
    restart();
  }

  function restart() {
    // // // Apply the general update pattern to the nodes.
    // node = node.data(nodes, function(d) { return d.id;});
    // node.exit().remove();
    // node = node.enter().append("circle").attr("fill", function(d) { return color(d.id); }).attr("r", 8).merge(node);

    node = node.data(nodes, function(d) { return d.id;});
    node.exit().remove();

    // Enter any new nodes.
    nodeEnter = node.enter().append("svg:g")
        .attr("class", "node");

    // Append a circle
    nodeEnter.append("svg:circle")
        .attr("r", function(d) { return 16; })
        .style("fill", "#eee");

    // Append images
    nodeEnter.append("svg:image")
          .attr("xlink:href",  d =>  userHash[d.id].profile.image_32)
          .attr("clip-path", "url(#clipCircle)")
          .attr("x", function(d) { return -16;})
          .attr("y", function(d) { return -16;});

    node = node.merge(nodeEnter);


    const edgeColorScale = d3.scaleLinear();
    edgeColorScale.domain([1, (1 + maxWeight) / 2, maxWeight]);
    edgeColorScale.range(['#00007f', '#ff7f00', '#ff0000']);

    // Apply the general update pattern to the links.
    link = link.data(links, function(d) { return d.source.id + "-" + d.target.id; });
    link.exit().remove();
    link.attr('stroke', edge => { const c = edgeColorScale(edge.weight); console.log(c); return c; });
    link = link.enter().append("line").merge(link);
    link.attr('stroke', edge => { const c = edgeColorScale(edge.weight); console.log(c); return c; });

    // Update and restart the simulation.
    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(1).restart();
  }

  function ticked() {
    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
  }

  function dragstarted(d) {
      if (!d3.event.active) {
        restart();
      }
      d.fx = d.x;
      d.fy = d.y;
  }

  function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
  }

  function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
  }

}


async function getChannelMap() {
  const channels = await (new Promise((res, rej) => {
    slack.channels.list({token}, (err, data) => {
      err ? rej(err) : res(data.channels);
    });
  }));

  return channels.reduce((out, chan) => {
    out[chan.id] = chan.members;
    return out;
  }, {});
}


async function getUserHash() {
  const users = await new Promise((res, rej) => {
    slack.users.list({token}, (err, data) => {
      err ? rej(err) : res(data.members);
    });
  });

  return users.reduce((out, user) => {
    out[user.id] = user;
    return out;
  }, {});
}



</script>